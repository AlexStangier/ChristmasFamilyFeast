<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weihnachts-Essensplaner</title>

    <!-- Vue 3 -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Google Fonts -->
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Mountains+of+Christmas:wght@700&display=swap"
        rel="stylesheet">

    <!-- Phosphor Icons -->
    <script src="https://unpkg.com/@phosphor-icons/web"></script>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        festive: ['"Mountains of Christmas"', 'cursive'],
                    },
                    colors: {
                        xmas: {
                            red: '#D42426',
                            green: '#165B33',
                            gold: '#F8B229',
                            cream: '#F0EAD6',
                            dark: '#0B2818'
                        }
                    }
                }
            }
        }
    </script>

    <style>
        body {
            background-color: #F0EAD6;
            background-image: radial-gradient(#D42426 0.5px, transparent 0.5px), radial-gradient(#165B33 0.5px, #F0EAD6 0.5px);
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
        }

        .snow-card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(4px);
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .hide-scroll::-webkit-scrollbar {
            height: 6px;
        }

        .hide-scroll::-webkit-scrollbar-track {
            background: transparent;
        }

        .hide-scroll::-webkit-scrollbar-thumb {
            background-color: #165B33;
            border-radius: 20px;
        }
    </style>
</head>

<body>

    <div id="app" class="min-h-screen flex flex-col items-center p-4 sm:p-6">

        <!-- Header -->
        <header
            class="w-full max-w-6xl flex justify-between items-center mb-8 bg-xmas-red text-white p-4 rounded-xl shadow-lg relative overflow-hidden">
            <div class="absolute top-0 left-0 w-full h-2 bg-xmas-gold/50"></div>
            <div class="z-10">
                <h1 class="text-3xl sm:text-4xl font-festive">Das Familienfest</h1>
                <p class="text-sm opacity-90">Weihnachtsplanung 2025</p>
            </div>
            <div class="z-10 flex items-center gap-3">
                <div v-if="currentUser" class="flex flex-col items-end">
                    <span class="text-xs uppercase tracking-wider opacity-75">Angemeldet als</span>
                    <span class="font-bold bg-white text-xmas-red px-2 py-0.5 rounded shadow-sm">{{ currentUser
                        }}</span>
                </div>
                <button v-if="currentUser" @click="logout"
                    class="bg-xmas-dark hover:bg-black text-white p-2 rounded-full transition-colors"
                    title="Rolle √§ndern">
                    <i class="ph ph-sign-out text-xl"></i>
                </button>
            </div>
            <i class="ph-fill ph-snowflake absolute -bottom-4 -right-4 text-8xl text-white opacity-20"></i>
        </header>

        <!-- Copy Mode Banner -->
        <div v-if="isCopyMode" class="fixed bottom-8 left-1/2 -translate-x-1/2 z-50 animate-fade-in">
            <div class="bg-xmas-dark text-white p-4 rounded-full shadow-2xl flex items-center gap-4 border-2 border-xmas-gold">
                <div class="flex flex-col">
                    <span class="font-bold text-sm">Kopiermodus aktiv</span>
                    <span class="text-xs opacity-75">W√§hle Tage f√ºr "{{ duplicateSource?.proposal.name }}"</span>
                </div>
                <button @click="stopCopyMode" class="bg-white text-xmas-dark px-4 py-2 rounded-full font-bold hover:bg-gray-200 transition-colors">
                    Fertig
                </button>
            </div>
        </div>

        <!-- Role Selection (Login) -->
        <div v-if="!currentUser"
            class="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/40 backdrop-blur-sm">
            <div class="snow-card w-full max-w-md p-8 text-center border-2 border-xmas-green relative overflow-hidden">
                <div class="absolute top-0 left-0 w-full h-4 bg-repeat-x"
                    style="background-image: repeating-linear-gradient(45deg, #D42426 0, #D42426 10px, #ffffff 10px, #ffffff 20px);">
                </div>
                <h2 class="text-3xl font-festive text-xmas-green mb-2 mt-4">Wer bist du?</h2>
                <p class="text-gray-600 mb-6">W√§hle deine Rolle, um zu beginnen.</p>
                <div class="grid grid-cols-2 gap-3">
                    <button v-for="role in roles" :key="role" @click="login(role)"
                        class="p-4 rounded-lg border-2 border-dashed border-xmas-gold hover:border-xmas-red hover:bg-red-50 transition-all group flex flex-col items-center gap-2">
                        <i class="ph-fill text-3xl"
                            :class="getRoleIcon(role) + ' text-xmas-green group-hover:text-xmas-red'"></i>
                        <span class="font-bold text-gray-700">{{ role }}</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- Main Planner Board -->
        <main v-else class="w-full max-w-7xl overflow-hidden flex flex-col gap-6">

            <!-- Legend -->
            <div
                class="flex flex-wrap gap-4 items-center justify-center text-sm text-gray-700 bg-white/80 p-3 rounded-full shadow-sm w-fit mx-auto backdrop-blur">
                <div class="flex items-center gap-1.5"><span class="w-3 h-3 rounded-full bg-xmas-green"></span>
                    Genehmigt
                </div>
                <div class="flex items-center gap-1.5"><span class="w-3 h-3 rounded-full bg-xmas-gold"></span> Favorit
                </div>
                <div class="flex items-center gap-1.5"><span class="w-3 h-3 rounded-full bg-gray-300"></span> Vorschlag
                </div>
                <div class="h-4 w-px bg-gray-300 mx-2"></div>
                <span class="italic text-xmas-red">"Nur der Organisator kann ein Gericht festlegen!"</span>
            </div>

            <!-- Scrollable Grid -->
            <div class="overflow-x-auto hide-scroll pb-6">
                <div class="flex gap-4 min-w-max px-2">

                    <!-- Day Column -->
                    <div v-for="day in days" :key="day.date" class="w-72 sm:w-80 flex flex-col gap-3">
                        <div class="snow-card p-3 text-center border-t-4 border-xmas-red sticky top-0 z-10">
                            <h3 class="font-festive text-2xl text-gray-800">{{ formatDate(day.date) }}</h3>
                            <p class="text-xs text-gray-500 uppercase tracking-widest">{{ day.name }}</p>
                        </div>

                        <div v-for="type in mealTypes" :key="type" class="flex flex-col h-full">
                            <div
                                class="snow-card p-4 flex flex-col gap-3 relative min-h-[160px] h-full transition-all hover:shadow-md overflow-hidden">

                                <!-- Copy Mode Overlay -->
                                <div v-if="isCopyMode" 
                                    @click.stop="handleSlotCopyClick(day.date, type)"
                                    class="absolute inset-0 z-50 flex items-center justify-center transition-all duration-300"
                                    :class="isTargetSlot(day.date, type) 
                                        ? 'bg-xmas-green/10 cursor-pointer hover:bg-xmas-green/20 ring-4 ring-inset ring-xmas-gold animate-pulse' 
                                        : 'bg-gray-100/80 backdrop-blur-[1px] cursor-not-allowed'">
                                    
                                    <div v-if="isTargetSlot(day.date, type)" 
                                        class="bg-white text-xmas-green font-bold px-4 py-2 rounded-full shadow-lg transform hover:scale-110 transition-transform flex items-center gap-2">
                                        <i class="ph-bold ph-copy-simple"></i>
                                        <span>Hier einf√ºgen</span>
                                    </div>
                                </div>

                                <!-- Slot Header -->
                                <div class="flex justify-between items-center border-b border-gray-100 pb-2">
                                    <span class="text-xs font-bold text-gray-400 uppercase">{{ type }}</span>
                                    <i v-if="isSignatureDish(day.date, type)" class="ph-fill ph-lock-key text-xmas-gold"
                                        title="Tradition!"></i>
                                </div>

                                <!-- Signature Dish -->
                                <div v-if="isSignatureDish(day.date, type)"
                                    class="flex-1 flex flex-col items-center justify-center text-center p-2 bg-xmas-red/5 rounded-lg border border-xmas-red/20">
                                    <i class="ph-fill ph-cooking-pot text-3xl text-xmas-red mb-2"></i>
                                    <h4 class="font-festive text-xl text-xmas-dark">Traditionsgericht</h4>
                                    <p class="text-sm font-medium text-gray-700">K√∂nigsberger Klopse</p>
                                </div>

                                <!-- Proposals -->
                                <div v-else class="flex flex-col gap-3 flex-1">
                                    <div v-if="getProposals(day.date, type).length > 0" class="flex flex-col gap-2">
                                        <div v-for="prop in getProposals(day.date, type)" :key="prop.id"
                                            class="p-2 rounded border transition-colors relative group"
                                            :class="getProposalClass(prop, day.date, type)">

                                            <i v-if="isLeading(prop, day.date, type)"
                                                class="ph-fill ph-crown-simple absolute -top-2 -right-2 text-xmas-gold text-xl drop-shadow-sm bg-white rounded-full p-0.5 z-10"></i>
                                            <div v-if="isLeading(prop, day.date, type)"
                                                class="absolute -top-2 -right-2 bg-xmas-gold text-white text-[10px] font-bold px-1.5 rounded-full z-20 shadow-sm border border-white">
                                                #1</div>

                                            <div class="flex justify-between items-start">
                                                <div class="flex-1">
                                                    <p class="font-bold text-gray-800 leading-tight">{{ prop.name }}</p>
                                                    <p class="text-xs text-gray-500 mt-0.5">von {{ prop.proposer }}</p>
                                                    <button v-if="prop.recipeUrl || prop.ingredients"
                                                        @click.stop="openRecipeModal(prop)"
                                                        class="text-xs text-xmas-red hover:underline flex items-center gap-1 mt-1">
                                                        <i class="ph-bold ph-book-open"></i> Rezept ansehen
                                                    </button>
                                                </div>
                                                <div class="flex flex-col items-end gap-1">
                                                    <div class="text-center min-w-[30px]">
                                                        <span class="text-sm font-bold block"
                                                            :class="hasVotedFor(prop) ? 'text-xmas-red' : 'text-gray-400'">{{
                                                            (prop.votes || []).length }}</span>
                                                    </div>
                                                    <button
                                                        v-if="currentUser === 'Organisator' || currentUser === prop.proposer"
                                                        @click="deleteProposal(day.date, type, prop.id)"
                                                        class="opacity-0 group-hover:opacity-100 transition-opacity text-gray-400 hover:text-red-500 p-1"
                                                        title="L√∂schen">
                                                        <i class="ph-bold ph-trash text-sm"></i>
                                                    </button>
                                                    <button v-if="!slotIsApproved(day.date, type)"
                                                        @click="startCopyMode(day.date, type, prop)"
                                                        class="opacity-0 group-hover:opacity-100 transition-opacity text-gray-400 hover:text-xmas-gold p-1"
                                                        title="Zu anderen Tagen kopieren">
                                                        <i class="ph-bold ph-copy text-sm"></i>
                                                    </button>
                                                </div>
                                            </div>

                                            <div class="flex gap-1 mt-2">
                                                <button @click="toggleVote(day.date, type, prop)"
                                                    class="flex-1 text-xs py-1 rounded flex items-center justify-center gap-1 transition-colors"
                                                    :class="hasVotedFor(prop) ? 'bg-xmas-red text-white' : 'bg-gray-100 hover:bg-gray-200 text-gray-600'">
                                                    <i class="ph"
                                                        :class="hasVotedFor(prop) ? 'ph-heart-fill' : 'ph-heart'"></i>
                                                    {{ hasVotedFor(prop) ? 'Gew√§hlt' : 'W√§hlen' }}
                                                </button>
                                                <button v-if="!prop.recipeUrl && !prop.isLoadingRecipe"
                                                    @click.stop="findRecipe(day.date, type, prop)"
                                                    class="px-2 bg-xmas-gold/10 text-xmas-gold hover:bg-xmas-gold/20 rounded transition-colors"
                                                    title="Rezept suchen">
                                                    <i class="ph-bold ph-magic-wand"></i>
                                                </button>
                                                <div v-if="prop.isLoadingRecipe"
                                                    class="px-2 flex items-center justify-center text-xmas-gold">
                                                    <i class="ph-bold ph-spinner animate-spin"></i>
                                                </div>
                                            </div>

                                            <button
                                                v-if="currentUser === 'Organisator' && !slotIsApproved(day.date, type)"
                                                @click="approveDish(day.date, type, prop)"
                                                class="w-full mt-1 text-xs py-1 bg-xmas-green text-white rounded hover:bg-green-800 transition-colors flex items-center justify-center gap-1">
                                                <i class="ph-bold ph-check"></i> Genehmigen
                                            </button>
                                        </div>
                                    </div>

                                    <div v-else class="flex-1 flex items-center justify-center text-center opacity-40">
                                        <p class="text-xs italic">Noch keine Pl√§ne.</p>
                                    </div>

                                    <button @click="openProposalModal(day.date, type)"
                                        class="mt-auto w-full py-2 border-2 border-dashed border-gray-200 rounded-lg text-gray-400 text-sm hover:border-xmas-green hover:text-xmas-green transition-all flex items-center justify-center gap-1">
                                        <i class="ph-bold ph-plus"></i> Vorschlagen
                                    </button>
                                </div>

                            </div>
                        </div>
                    </div>

                </div>
            </div>

        </main>

        <!-- Grocery List Section -->
        <section v-if="groceryList.length > 0" class="w-full max-w-6xl mt-8 mb-8">
            <div class="snow-card p-6 border-t-4 border-xmas-gold">
                <div class="flex items-center justify-between mb-4">
                    <div class="flex items-center gap-3">
                        <i class="ph-fill ph-basket text-3xl text-xmas-gold"></i>
                        <h2 class="font-festive text-3xl text-gray-800">Einkaufsliste</h2>
                    </div>
                    <button @click="openExportModal" class="text-sm bg-gray-100 hover:bg-gray-200 text-gray-600 px-3 py-1.5 rounded-lg transition-colors flex items-center gap-2">
                         <i class="ph-bold ph-export"></i> Exportieren
                    </button>
                </div>
                <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">
                    <div v-for="(item, index) in mergedGroceryList" :key="index"
                        class="flex items-center gap-2 p-2 bg-white rounded border border-gray-100 shadow-sm"
                        :class="{'border-xmas-gold/50 bg-yellow-50': item.isPlaceholder}">
                        <input type="checkbox"
                            class="w-4 h-4 text-xmas-green rounded focus:ring-xmas-green accent-xmas-green shrink-0">
                        
                        <span class="flex-1 text-gray-700 text-sm break-words">{{ item.text }}</span>
                        
                        <button v-if="item.isPlaceholder" 
                            @click="retryLoadingIngredients(item)"
                            class="text-xmas-gold hover:text-xmas-dark transition-colors p-1"
                            title="Zutaten laden"
                            :disabled="loadingIngredientsFor === item.proposalId">
                            <i class="ph-bold" :class="loadingIngredientsFor === item.proposalId ? 'ph-spinner animate-spin' : 'ph-arrow-clockwise'"></i>
                        </button>
                    </div>
                    <!-- Add new item -->
                    <div
                        class="flex items-center gap-2 p-2 bg-gray-50 rounded border-2 border-dashed border-gray-200 hover:border-xmas-green transition-colors">
                        <i class="ph-bold ph-plus text-gray-400 shrink-0"></i>
                        <input v-model="newGroceryItem" @keyup.enter="addGroceryItem" placeholder="Neues Element..."
                            class="flex-1 text-sm bg-transparent outline-none text-gray-700 placeholder-gray-400">
                        <button v-if="newGroceryItem.trim()" @click="addGroceryItem"
                            class="text-xmas-green hover:text-green-700 transition-colors p-1" title="Hinzuf√ºgen">
                            <i class="ph-bold ph-check"></i>
                        </button>
                    </div>
                </div>
            </div>
        </section>

        <!-- Proposal Modal -->
        <div v-if="showProposalModal"
            class="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/40 backdrop-blur-sm"
            @click.self="closeProposalModal">
            <div class="snow-card w-full max-w-md p-6 relative">
                <button @click="closeProposalModal" class="absolute top-4 right-4 text-gray-400 hover:text-gray-600">
                    <i class="ph-bold ph-x text-xl"></i>
                </button>

                <h3 class="font-festive text-2xl text-xmas-green mb-4">Gericht vorschlagen</h3>

                <!-- Search -->
                <div class="mb-4 relative">
                    <div
                        class="flex items-center border border-gray-300 rounded-lg overflow-hidden focus-within:ring-2 focus-within:ring-xmas-gold">
                        <input v-model="proposalSearchQuery" @input="debouncedSearch"
                            placeholder="Was m√∂chtest du essen? (z.B. Ente, Pasta...)"
                            class="w-full p-3 outline-none text-gray-700">
                        <div v-if="isSearching" class="pr-3 text-gray-400">
                            <i class="ph-bold ph-spinner animate-spin"></i>
                        </div>
                    </div>

                    <!-- Suggestions -->
                    <div v-if="suggestions.length > 0"
                        class="absolute top-full left-0 w-full bg-white border border-gray-200 rounded-lg shadow-lg mt-1 z-10 max-h-48 overflow-y-auto">
                        <button v-for="sugg in suggestions" :key="sugg" @click="selectSuggestion(sugg)"
                            class="w-full text-left p-2 hover:bg-gray-50 text-sm text-gray-700 border-b border-gray-50 last:border-0">
                            {{ sugg }}
                        </button>
                    </div>
                </div>

                <!-- Custom Entry / Selected -->
                <div v-if="proposalSearchQuery" class="flex flex-col gap-3">
                    <button @click="submitProposalFromModal(proposalSearchQuery)"
                        class="w-full bg-xmas-green text-white py-3 rounded-lg font-bold hover:bg-green-800 transition-colors flex items-center justify-center gap-2">
                        <i class="ph-bold ph-plus-circle"></i> "{{ proposalSearchQuery }}" hinzuf√ºgen
                    </button>
                </div>

                <!-- Preview Section -->
                <div v-if="previewData" class="mt-6 border-t border-gray-200 pt-4">
                    <h4 class="font-bold text-gray-800 mb-3 flex items-center gap-2">
                        <i class="ph-fill ph-eye text-xmas-gold"></i> Vorschau
                    </h4>
                    <div class="grid md:grid-cols-2 gap-4">
                        <!-- Ingredients Preview -->
                        <div class="bg-gray-50 p-3 rounded-lg">
                            <h5 class="text-sm font-semibold text-gray-700 mb-2">Zutaten</h5>
                            <ul class="space-y-1">
                                <li v-for="(ing, i) in (previewData.ingredients || []).slice(0, 5)" :key="i"
                                    class="text-xs text-gray-600 flex items-start gap-1">
                                    <span class="w-1 h-1 rounded-full bg-xmas-green mt-1.5 shrink-0"></span>
                                    {{ ing }}
                                </li>
                                <li v-if="(previewData.ingredients || []).length > 5"
                                    class="text-xs text-gray-400 italic">+
                                    {{ previewData.ingredients.length - 5 }}
                                    weitere...</li>
                            </ul>
                        </div>

                        <!-- Instructions Preview -->
                        <div class="bg-gray-50 p-3 rounded-lg">
                            <h5 class="text-sm font-semibold text-gray-700 mb-2">Zubereitung</h5>
                            <ol class="space-y-1">
                                <li v-for="(step, i) in (previewData.instructions || []).slice(0, 3)" :key="i"
                                    class="text-xs text-gray-600 flex gap-2">
                                    <span class="font-bold text-xmas-gold shrink-0">{{ i + 1 }}.</span>
                                    <span class="line-clamp-2">{{ step }}</span>
                                </li>
                                <li v-if="(previewData.instructions || []).length > 3"
                                    class="text-xs text-gray-400 italic pl-4">+ {{ previewData.instructions.length - 3
                                    }} weitere Schritte...</li>
                            </ol>
                        </div>
                    </div>
                    <div v-if="previewData.url" class="mt-3">
                        <a :href="previewData.url" target="_blank"
                            class="text-xs text-xmas-red hover:underline flex items-center gap-1">
                            <i class="ph-bold ph-link"></i> Originalrezept ansehen
                        </a>
                    </div>
                </div>

                <div v-if="isLoadingPreview"
                    class="mt-6 border-t border-gray-200 pt-4 flex items-center justify-center gap-2 text-gray-500">
                    <i class="ph-bold ph-spinner animate-spin"></i>
                    <span class="text-sm">Lade Vorschau...</span>
                </div>
            </div>
        </div>

        <!-- Recipe Modal -->
        <div v-if="selectedRecipeProp"
            class="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/40 backdrop-blur-sm"
            @click.self="closeRecipeModal">
            <div class="snow-card w-full max-w-2xl p-0 relative flex flex-col max-h-[90vh]">
                <!-- Header -->
                <div class="p-6 border-b border-gray-100 flex justify-between items-start bg-gray-50 rounded-t-xl">
                    <div>
                        <h3 class="font-festive text-3xl text-xmas-red">{{ selectedRecipeProp.name }}</h3>
                        <p class="text-sm text-gray-500">Vorgeschlagen von {{ selectedRecipeProp.proposer }}</p>
                    </div>
                    <button @click="closeRecipeModal" class="text-gray-400 hover:text-gray-600">
                        <i class="ph-bold ph-x text-xl"></i>
                    </button>
                </div>

                <!-- Content -->
                <div class="p-6 overflow-y-auto hide-scroll">
                    <div class="grid md:grid-cols-2 gap-8">
                        <!-- Ingredients -->
                        <div>
                            <h4 class="font-bold text-gray-800 mb-3 flex items-center gap-2">
                                <i class="ph-fill ph-basket text-xmas-gold"></i> Zutaten
                            </h4>
                            <ul class="space-y-2">
                                <li v-for="(ing, i) in (selectedRecipeProp.ingredients || [])" :key="i"
                                    class="flex items-start gap-2 text-sm text-gray-600">
                                    <span class="w-1.5 h-1.5 rounded-full bg-xmas-green mt-1.5 shrink-0"></span>
                                    {{ ing }}
                                </li>
                                <li v-if="!selectedRecipeProp.ingredients" class="text-sm text-gray-400 italic">Keine
                                    Zutaten geladen.</li>
                            </ul>
                        </div>

                        <!-- Instructions -->
                        <div>
                            <h4 class="font-bold text-gray-800 mb-3 flex items-center gap-2">
                                <i class="ph-fill ph-cooking-pot text-xmas-red"></i> Zubereitung
                            </h4>
                            <ol class="space-y-3">
                                <li v-for="(step, i) in (selectedRecipeProp.instructions || [])" :key="i"
                                    class="flex gap-3 text-sm text-gray-600">
                                    <span class="font-bold text-xmas-gold shrink-0">{{ i + 1 }}.</span>
                                    {{ step }}
                                </li>
                                <li v-if="!selectedRecipeProp.instructions" class="text-sm text-gray-400 italic">Keine
                                    Anleitung verf√ºgbar.</li>
                            </ol>
                        </div>
                    </div>

                    <div class="mt-8 flex flex-wrap gap-3">
                        <a v-if="selectedRecipeProp.recipeUrl" :href="selectedRecipeProp.recipeUrl" target="_blank"
                            class="bg-gray-100 hover:bg-gray-200 text-gray-700 px-4 py-2 rounded-lg text-sm font-medium transition-colors flex items-center gap-2">
                            <i class="ph-bold ph-link"></i> Originalrezept √∂ffnen
                        </a>

                        <button v-if="currentUser === selectedRecipeProp.proposer && !selectedRecipeProp.approved"
                            @click="withdrawProposal(selectedRecipeProp)"
                            class="ml-auto text-red-500 hover:bg-red-50 px-4 py-2 rounded-lg text-sm font-medium transition-colors flex items-center gap-2 border border-red-200">
                            <i class="ph-bold ph-trash"></i> Vorschlag zur√ºckziehen
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Recipe Modal -->

        <!-- Export Modal -->
        <div v-if="showExportModal"
            class="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/40 backdrop-blur-sm"
            @click.self="showExportModal = false">
            <div class="snow-card w-full max-w-md p-6 relative">
                <button @click="showExportModal = false" class="absolute top-4 right-4 text-gray-400 hover:text-gray-600">
                    <i class="ph-bold ph-x text-xl"></i>
                </button>

                <h3 class="font-festive text-2xl text-xmas-green mb-4">Einkaufsliste Export</h3>
                
                <textarea 
                    readonly 
                    class="w-full h-64 p-3 border border-gray-200 rounded-lg text-sm font-mono text-gray-700 focus:outline-none focus:border-xmas-gold bg-gray-50 resize-none"
                    :value="exportText"
                    @click="$event.target.select()"
                ></textarea>

                <p class="text-xs text-gray-400 mt-2 text-center">Text kopieren und teilen!</p>
            </div>
        </div>

        <!-- Activity Log Tab -->
        <div class="fixed bottom-0 right-4 z-50">
            <!-- Collapsed Tab -->
            <button v-if="!showActivityLog" @click="showActivityLog = true"
                class="snow-card px-4 py-2 rounded-t-lg shadow-lg flex items-center gap-2 hover:bg-gray-50 transition-colors">
                <i class="ph-bold ph-chats-circle text-xmas-gold"></i>
                <span class="font-semibold text-gray-700">Aktivit√§ten</span>
                <span v-if="activityLog.length > 0" class="bg-xmas-red text-white text-xs px-2 py-0.5 rounded-full">{{
                    activityLog.length }}</span>
            </button>

            <!-- Expanded Log -->
            <div v-if="showActivityLog"
                class="snow-card w-96 h-96 flex flex-col shadow-2xl rounded-t-lg overflow-hidden">
                <!-- Header -->
                <div
                    class="bg-gradient-to-r from-xmas-green to-green-700 text-white p-3 flex justify-between items-center">
                    <div class="flex items-center gap-2">
                        <i class="ph-fill ph-chats-circle text-xl"></i>
                        <h3 class="font-bold">Aktivit√§tsprotokoll</h3>
                    </div>
                    <button @click="showActivityLog = false" class="hover:bg-white/20 rounded p-1 transition-colors">
                        <i class="ph-bold ph-x"></i>
                    </button>
                </div>

                <!-- Log Messages -->
                <div class="flex-1 overflow-y-auto p-3 space-y-2 bg-gray-50">
                    <div v-for="(log, index) in activityLog.slice().reverse()" :key="index"
                        class="bg-white rounded-lg p-3 shadow-sm border-l-4" :class="{
                            'border-xmas-green': log.type === 'add',
                            'border-xmas-gold': log.type === 'edit',
                            'border-xmas-red': log.type === 'delete',
                            'border-blue-500': log.type === 'vote',
                            'border-purple-500': log.type === 'approve'
                        }">
                        <div class="flex items-start gap-2">
                            <div class="shrink-0 w-8 h-8 rounded-full bg-gray-100 flex items-center justify-center text-xs font-bold"
                                :class="{
                                    'bg-xmas-green/10 text-xmas-green': log.user === 'Organisator',
                                    'bg-blue-100 text-blue-600': log.user === 'Eltern',
                                    'bg-purple-100 text-purple-600': log.user === 'Hamburg',
                                    'bg-orange-100 text-orange-600': log.user === 'Konstanz'
                                }">
                                {{ log.user.substring(0, 2).toUpperCase() }}
                            </div>
                            <div class="flex-1 min-w-0">
                                <div class="flex items-center gap-2 mb-1">
                                    <span class="font-semibold text-sm text-gray-800">{{ log.user }}</span>
                                    <span class="text-xs text-gray-400">{{ formatLogTime(log.timestamp) }}</span>
                                </div>
                                <p class="text-sm text-gray-600">{{ log.message }}</p>
                            </div>
                        </div>
                    </div>
                    <div v-if="activityLog.length === 0" class="text-center text-gray-400 py-8">
                        <i class="ph-bold ph-chat-centered-dots text-4xl mb-2"></i>
                        <p class="text-sm">Noch keine Aktivit√§ten</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Sync Footer -->
        <footer class="mt-auto py-6 w-full max-w-6xl flex justify-between items-center text-sm font-festive text-xl">
            <div class="flex items-center gap-2 text-gray-500">
                <div class="w-2 h-2 rounded-full" :class="{
                    'bg-green-500': syncStatus === 'saved',
                    'bg-yellow-400 animate-pulse': syncStatus === 'syncing',
                    'bg-red-500': syncStatus === 'error'
                }"></div>
                <span class="font-sans text-xs uppercase tracking-wider font-bold">
                    {{ syncMessage }}
                </span>
            </div>
            <p class="text-xmas-dark/50">Gemacht mit üéÑ f√ºr die Familie</p>
        </footer>

    </div>

    <script type="module">
        const { createApp, ref, computed, onMounted, watch } = Vue;

        createApp({
            setup() {
                // -- State --
                const currentUser = ref(null);
                const mealSlots = ref({});
                const groceryList = ref([]);
                const newProposalText = ref("");
                const showForm = ref({});

                // Modal State
                const showProposalModal = ref(false);
                const activeSlot = ref(null);
                const proposalSearchQuery = ref("");
                const suggestions = ref([]);
                const isSearching = ref(false);
                const selectedRecipeProp = ref(null);
                const previewData = ref(null);
                const isLoadingPreview = ref(false);
                const editingGroceryIndex = ref(null);
                const editingGroceryText = ref("");
                const newGroceryItem = ref("");
                const activityLog = ref([]);
                const showActivityLog = ref(false);
                const showDuplicateModal = ref(false);
                const duplicateSource = ref(null);
                const selectedDuplicateDays = ref([]);

                const showExportModal = ref(false);
                const exportText = ref("");

                // Sync State
                const syncStatus = ref('saved'); // 'saved', 'syncing', 'error'
                const syncMessage = ref('Alle √Ñnderungen gespeichert');
                const isFirstLoad = ref(true);

                const roles = ['Organisator', 'Eltern', 'Hamburg', 'Konstanz'];
                const mealTypes = ['Mittagessen', 'Abendessen', 'Dessert'];
                const days = [
                    { date: '2025-12-23', name: 'Anreisetag' },
                    { date: '2025-12-24', name: 'Heiligabend' },
                    { date: '2025-12-25', name: '1. Weihnachtstag' },
                    { date: '2025-12-26', name: '2. Weihnachtstag' },
                    { date: '2025-12-27', name: 'Abreisetag' }
                ];

                // -- API Sync Logic --
                const API_ENDPOINT = '/api/data';
                let saveTimeout = null;
                const currentETag = ref(null); // Store server version

                const fetchData = async () => {
                    // If we are currently typing/saving, don't fetch to avoid jitter
                    if (syncStatus.value === 'syncing' && !isFirstLoad.value) return;

                    try {
                        const res = await fetch(API_ENDPOINT);
                        if (!res.ok) throw new Error('Network error');
                        
                        // Capture ETag
                        const etag = res.headers.get('ETag');
                        if (etag) currentETag.value = etag;

                        const data = await res.json();

                        // Simple deep compare could go here, but for now we just replace
                        // Only replace if structure differs to avoid UI resets
                        if (JSON.stringify(data) !== JSON.stringify(mealSlots.value)) {
                            mealSlots.value = data.slots || data; // Handle old format fallback
                            if (data.groceries) groceryList.value = data.groceries;
                            if (isFirstLoad.value) {
                                console.log("Initial data loaded");
                                isFirstLoad.value = false;
                            }
                        }
                    } catch (e) {
                        console.log("Polling error (offline?)", e);
                    }
                };

                const saveData = async () => {
                    syncStatus.value = 'syncing';
                    syncMessage.value = 'Synchronisiere mit Cloud...';

                    try {
                        const headers = { 'Content-Type': 'application/json' };
                        // Send If-Match if we have an ETag
                        if (currentETag.value) {
                            headers['If-Match'] = currentETag.value;
                        }

                        const res = await fetch(API_ENDPOINT, {
                            method: 'POST',
                            headers: headers,
                            body: JSON.stringify({ slots: mealSlots.value, groceries: groceryList.value })
                        });

                        if (res.status === 409) {
                            // Conflict!
                            syncStatus.value = 'error';
                            syncMessage.value = 'Konflikt! Daten wurden extern ge√§ndert.';
                            if (confirm("Jemand anderes hat √Ñnderungen vorgenommen. Seite neu laden, um Datenverlust zu vermeiden?")) {
                                window.location.reload();
                            }
                            return;
                        }

                        if (!res.ok) throw new Error('Save failed');

                        // On success, we assume our version is now current, but ideally we should get a new ETag.
                        // For now, next poll will update ETag, or we could optimistically update if server returned it.
                        // We will rely on polling to catch up ETag if we continue editing.
                        // Actually, to prevent immediate subsequent save fail, we should probably fetch immediately?
                        // Or just clear ETag and let next fetch handle it? 
                        // Safest: Refetch immediately to get new ETag.
                        fetchData();

                        syncStatus.value = 'saved';
                        syncMessage.value = 'Alle √Ñnderungen gespeichert';
                    } catch (e) {
                        console.error(e);
                        syncStatus.value = 'error';
                        syncMessage.value = 'Sync Fehler - Erneuter Versuch...';
                    }
                };

                const debouncedSave = () => {
                    if (isFirstLoad.value) return; // Don't save on initial empty state

                    syncStatus.value = 'syncing';
                    syncMessage.value = 'Warte auf Speichern...';

                    if (saveTimeout) clearTimeout(saveTimeout);

                    // Debounce for 2 seconds
                    saveTimeout = setTimeout(saveData, 2000);
                };

                // -- Initialization --
                onMounted(() => {
                    const savedRole = localStorage.getItem('christmas_role');
                    if (savedRole && roles.includes(savedRole)) {
                        currentUser.value = savedRole;
                    }

                    // Initial Fetch
                    fetchData();

                    // Start Polling (every 5 seconds) to get family updates
                    setInterval(fetchData, 5000);
                });

                // -- Watcher for Auto-Save --
                watch([mealSlots, groceryList], () => {
                    debouncedSave();
                }, { deep: true });

                // -- Helpers & Logic (Same as before) --
                const getSlotKey = (date, type) => `${date}_${type.toLowerCase()}`;
                const isSignatureDish = (date, type) => date === '2025-12-24' && type === 'Abendessen';
                const slotIsApproved = (date, type) => {
                    const key = getSlotKey(date, type);
                    return mealSlots.value[key]?.approved;
                };
                const formatDate = (dateStr) => new Date(dateStr).toLocaleDateString('de-DE', { day: 'numeric', month: 'short' });

                const getRoleIcon = (role) => {
                    const map = { 'Organisator': 'ph-clipboard-text', 'Eltern': 'ph-house-line', 'Hamburg': 'ph-anchor', 'Konstanz': 'ph-waves' };
                    return map[role] || 'ph-user';
                };

                const getProposals = (date, type) => {
                    const key = getSlotKey(date, type);
                    return [...(mealSlots.value[key]?.proposals || [])].sort((a, b) => (b.votes?.length || 0) - (a.votes?.length || 0));
                };

                const isLeading = (proposal, date, type) => {
                    const props = getProposals(date, type);
                    if (!props.length) return false;
                    const maxVotes = Math.max(...props.map(p => (p.votes || []).length));
                    const proposalVotes = (proposal.votes || []).length;

                    // Must have max votes and at least 1 vote
                    if (maxVotes === 0 || proposalVotes !== maxVotes) return false;

                    // Tiebreaker: only the first proposal with max votes gets #1
                    const firstWithMaxVotes = props.find(p => (p.votes || []).length === maxVotes);
                    return firstWithMaxVotes && firstWithMaxVotes.id === proposal.id;
                };

                const getProposalClass = (proposal, date, type) => {
                    if (slotIsApproved(date, type)) {
                        return proposal.approved ? 'bg-xmas-green/10 border-xmas-green ring-2 ring-xmas-green' : 'opacity-50 grayscale bg-gray-50';
                    }
                    return isLeading(proposal, date, type) ? 'bg-xmas-gold/10 border-xmas-gold' : 'bg-white border-gray-200 hover:border-gray-300';
                };
                const hasVotedFor = (prop) => (prop.votes || []).includes(currentUser.value);

                // -- Actions --
                const login = (role) => {
                    currentUser.value = role;
                    localStorage.setItem('christmas_role', role);
                };
                const logout = () => {
                    currentUser.value = null;
                    localStorage.removeItem('christmas_role');
                };
                const openForm = (date, type) => {
                    showForm.value = { [date + type]: true };
                    newProposalText.value = "";
                };
                const closeForm = (date, type) => { showForm.value[date + type] = false; };

                const submitProposal = (date, type) => {
                    if (!newProposalText.value.trim() || !currentUser.value) return;
                    const key = getSlotKey(date, type);
                    if (!mealSlots.value[key]) mealSlots.value[key] = { date, type, proposals: [] };

                    mealSlots.value[key].proposals.push({
                        id: crypto.randomUUID(),
                        name: newProposalText.value.trim(),
                        proposer: currentUser.value,
                        votes: [currentUser.value]
                    });

                    logActivity('add', `hat "${newProposalText.value.trim()}" f√ºr ${type} am ${formatDate(date)} vorgeschlagen`);
                    closeForm(date, type);
                };

                const toggleVote = (date, type, proposal) => {
                    if (!currentUser.value) return;
                    const target = proposal;
                    if (!target.votes) target.votes = [];

                    if (target.votes.includes(currentUser.value)) {
                        target.votes = target.votes.filter(v => v !== currentUser.value);
                        logActivity('vote', `hat die Stimme f√ºr "${proposal.name}" zur√ºckgezogen`);
                    } else {
                        target.votes.push(currentUser.value);
                        logActivity('vote', `hat f√ºr "${proposal.name}" gestimmt`);
                    }
                };

                const approveDish = async (date, type, proposal) => {
                    const key = getSlotKey(date, type);
                    if (!mealSlots.value[key]) return;

                    // If ingredients not loaded yet, fetch them first
                    if (!proposal.ingredients || proposal.ingredients.length === 0) {
                        proposal.isLoadingRecipe = true;
                        try {
                            const res = await fetch('/api/ai/recipe', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ dish_name: proposal.name })
                            });
                            const data = await res.json();
                            if (data.url) proposal.recipeUrl = data.url;
                            if (data.ingredients) proposal.ingredients = data.ingredients;
                            if (data.instructions) proposal.instructions = data.instructions;
                        } catch (e) {
                            console.error("Recipe fetch failed during approval", e);
                        } finally {
                            proposal.isLoadingRecipe = false;
                        }
                    }

                    mealSlots.value[key].approved = true;
                    proposal.approved = true;

                    // Add ingredients to grocery list
                    if (proposal.ingredients && proposal.ingredients.length > 0) {
                        // Avoid duplicates (simple check)
                        const existingStrings = groceryList.value.map(g => typeof g === 'string' ? g : g.text);
                        const newItems = proposal.ingredients.filter(i => !existingStrings.includes(i));
                        groceryList.value.push(...newItems);
                    } else {
                        // If still no ingredients, add placeholder object
                        groceryList.value.push({
                            text: `${proposal.name} (Zutaten pr√ºfen)`,
                            isPlaceholder: true,
                            proposalId: proposal.id,
                            dishName: proposal.name,
                            date: date,
                            type: type
                        });
                    }

                    logActivity('approve', `hat "${proposal.name}" genehmigt`);
                };

                const deleteProposal = (date, type, proposalId) => {
                    if (!confirm("M√∂chtest du diesen Vorschlag wirklich l√∂schen?")) return;

                    const key = getSlotKey(date, type);
                    if (mealSlots.value[key] && mealSlots.value[key].proposals) {
                        const proposal = mealSlots.value[key].proposals.find(p => p.id === proposalId);

                        // Remove ingredients from grocery list if approved
                        if (proposal && proposal.approved) {
                             // Remove strict ingredients
                            if (proposal.ingredients) {
                                proposal.ingredients.forEach(ingredient => {
                                    const index = groceryList.value.findIndex(g => {
                                        const txt = typeof g === 'string' ? g : g.text;
                                        return txt === ingredient;
                                    });
                                    if (index > -1) groceryList.value.splice(index, 1);
                                });
                            }
                            // Remove placeholders
                            const placeholderIndex = groceryList.value.findIndex(g => typeof g === 'object' && g.proposalId === proposalId);
                            if (placeholderIndex > -1) groceryList.value.splice(placeholderIndex, 1);
                        }

                        if (proposal) {
                            logActivity('delete', `hat "${proposal.name}" gel√∂scht`);
                        }

                        // Remove proposal
                        mealSlots.value[key].proposals = mealSlots.value[key].proposals.filter(p => p.id !== proposalId);

                        // If it was approved, unapprove the slot
                        if (proposal && proposal.approved) {
                            mealSlots.value[key].approved = false;
                        }
                    }
                };

                // -- Modal Logic --

                const openProposalModal = (date, type) => {
                    activeSlot.value = { date, type };
                    proposalSearchQuery.value = "";
                    suggestions.value = [];
                    showProposalModal.value = true;
                };

                const closeProposalModal = () => {
                    showProposalModal.value = false;
                    activeSlot.value = null;
                    previewData.value = null;
                    isLoadingPreview.value = false;
                };

                let searchTimeout;
                const debouncedSearch = () => {
                    if (searchTimeout) clearTimeout(searchTimeout);
                    if (!proposalSearchQuery.value || proposalSearchQuery.value.length < 2) {
                        suggestions.value = [];
                        return;
                    }

                    searchTimeout = setTimeout(async () => {
                        isSearching.value = true;
                        try {
                            const res = await fetch('/api/ai/suggest', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ query: proposalSearchQuery.value })
                            });
                            const data = await res.json();
                            suggestions.value = data.suggestions || [];
                        } catch (e) {
                            console.error(e);
                        } finally {
                            isSearching.value = false;
                        }
                    }, 500);
                };

                const selectSuggestion = (sugg) => {
                    proposalSearchQuery.value = sugg;
                    suggestions.value = [];
                    // Fetch preview
                    fetchPreview(sugg);
                };

                const fetchPreview = async (dishName) => {
                    isLoadingPreview.value = true;
                    previewData.value = null;
                    try {
                        const res = await fetch('/api/ai/recipe', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ dish_name: dishName })
                        });
                        const data = await res.json();
                        previewData.value = data;
                    } catch (e) {
                        console.error("Preview fetch failed", e);
                    } finally {
                        isLoadingPreview.value = false;
                    }
                };

                const submitProposalFromModal = (name) => {
                    if (!activeSlot.value || !currentUser.value) return;
                    const { date, type } = activeSlot.value;
                    const key = getSlotKey(date, type);

                    if (!mealSlots.value[key]) mealSlots.value[key] = { date, type, proposals: [] };

                    const newProposal = {
                        id: crypto.randomUUID(),
                        name: name,
                        proposer: currentUser.value,
                        votes: [currentUser.value]
                    };

                    // If we have preview data, reuse it to speed up
                    if (previewData.value && previewData.value.url) {
                        newProposal.recipeUrl = previewData.value.url;
                        newProposal.ingredients = previewData.value.ingredients || [];
                        newProposal.instructions = previewData.value.instructions || [];
                    }

                    mealSlots.value[key].proposals.push(newProposal);

                    // Only fetch recipe if we don't have preview data
                    if (!previewData.value || !previewData.value.url) {
                        const newProp = mealSlots.value[key].proposals[mealSlots.value[key].proposals.length - 1];
                        findRecipe(date, type, newProp);
                    }

                    logActivity('add', `hat "${name}" f√ºr ${type} am ${formatDate(date)} vorgeschlagen`);
                    closeProposalModal();
                };

                const openRecipeModal = (prop) => {
                    selectedRecipeProp.value = prop;
                };

                const closeRecipeModal = () => {
                    selectedRecipeProp.value = null;
                };

                const withdrawProposal = (prop) => {
                    // Find slot
                    for (const key in mealSlots.value) {
                        const slot = mealSlots.value[key];
                        if (slot.proposals.some(p => p.id === prop.id)) {
                            deleteProposal(slot.date, slot.type, prop.id);
                            closeRecipeModal();
                            return;
                        }
                    }
                };

                // Update findRecipe to handle instructions
                const findRecipe = async (date, type, proposal) => {
                    proposal.isLoadingRecipe = true;
                    try {
                        const res = await fetch('/api/ai/recipe', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ dish_name: proposal.name })
                        });
                        const data = await res.json();
                        if (data.url) proposal.recipeUrl = data.url;
                        if (data.ingredients) proposal.ingredients = data.ingredients;
                        if (data.instructions) proposal.instructions = data.instructions;
                    } catch (e) {
                        console.error("Recipe lookup failed", e);
                        // Don't alert, just fail silently in background
                    } finally {
                        proposal.isLoadingRecipe = false;
                    }
                };

                // -- Grocery List Editing --

                const startEditGrocery = (index) => {
                    editingGroceryIndex.value = index;
                    editingGroceryText.value = groceryList.value[index];
                };

                const saveGroceryEdit = (index) => {
                    if (editingGroceryText.value.trim()) {
                        groceryList.value[index] = editingGroceryText.value.trim();
                    }
                    cancelGroceryEdit();
                };

                const cancelGroceryEdit = () => {
                    editingGroceryIndex.value = null;
                    editingGroceryText.value = "";
                };

                const removeGroceryItem = (index) => {
                    groceryList.value.splice(index, 1);
                };

                const addGroceryItem = () => {
                    if (newGroceryItem.value.trim()) {
                        groceryList.value.push(newGroceryItem.value.trim());
                        newGroceryItem.value = "";
                    }
                };

                // -- Copy/Paste Mode (formerly Duplicate) --

                const isCopyMode = computed(() => !!duplicateSource.value);

                const startCopyMode = (sourceDate, sourceType, proposal) => {
                    duplicateSource.value = { date: sourceDate, type: sourceType, proposal };
                };

                const stopCopyMode = () => {
                    duplicateSource.value = null;
                };

                const isTargetSlot = (date, type) => {
                    if (!isCopyMode.value) return false;
                    
                    const source = duplicateSource.value;
                    
                    // Don't copy to self (same date AND same type)
                    if (date === source.date && type === source.type) return false;

                    // Type Compatibility Check
                    if (source.type === 'Dessert') {
                        return type === 'Dessert';
                    } else {
                        // Meals (Mittagessen/Abendessen) can only go to Meals
                        return type === 'Mittagessen' || type === 'Abendessen';
                    }
                };

                const handleSlotCopyClick = (targetDate, targetType) => {
                    if (!isTargetSlot(targetDate, targetType)) return;

                    const { proposal } = duplicateSource.value;
                    const key = getSlotKey(targetDate, targetType);

                    if (!mealSlots.value[key]) mealSlots.value[key] = { date: targetDate, type: targetType, proposals: [] };

                    // Check if already exists (by name)
                    const exists = mealSlots.value[key].proposals.some(p => p.name.toLowerCase() === proposal.name.toLowerCase());
                    if (exists) {
                        alert(`"${proposal.name}" gibt es am ${formatDate(targetDate)} schon!`);
                        return;
                    }

                    // Create copy
                    const newProposal = {
                        id: crypto.randomUUID(),
                        name: proposal.name,
                        proposer: currentUser.value,
                        votes: [currentUser.value],
                        recipeUrl: proposal.recipeUrl,
                        ingredients: proposal.ingredients ? [...proposal.ingredients] : [],
                        instructions: proposal.instructions ? [...proposal.instructions] : []
                    };

                    mealSlots.value[key].proposals.push(newProposal);
                    logActivity('add', `hat "${proposal.name}" kopiert nach ${formatDate(targetDate)}`);
                };

                // -- Activity Log --

                const logActivity = (type, message) => {
                    if (!currentUser.value) return;
                    activityLog.value.push({
                        type,
                        user: currentUser.value,
                        message,
                        timestamp: new Date().toISOString()
                    });
                };

                const formatLogTime = (timestamp) => {
                    const date = new Date(timestamp);
                    const now = new Date();
                    const diff = now - date;

                    if (diff < 60000) return 'Gerade eben';
                    if (diff < 3600000) return `vor ${Math.floor(diff / 60000)} Min`;
                    if (diff < 86400000) return `vor ${Math.floor(diff / 3600000)} Std`;
                    return date.toLocaleDateString('de-DE', { day: '2-digit', month: '2-digit', hour: '2-digit', minute: '2-digit' });
                };

                // -- Smart Grocery List Merging --

                const parseIngredient = (ingredient) => {
                    // Try to extract quantity and unit from ingredient string
                    // Patterns: "500g Mehl", "2 Zwiebeln", "1 EL √ñl", "Salz"
                    const match = ingredient.match(/^([\d.,]+)\s*([a-zA-Z√§√∂√º√Ñ√ñ√ú√ü]*)?\s+(.+)$/);
                    if (match) {
                        return {
                            quantity: parseFloat(match[1].replace(',', '.')),
                            unit: match[2] || '',
                            name: match[3].trim()
                        };
                    }
                    // No quantity found, treat as single item
                    return { quantity: null, unit: '', name: ingredient.trim() };
                };

                const getMergedItems = () => {
                    const merged = {};
                    const placeholders = [];

                    groceryList.value.forEach(item => {
                        // Handle Placeholder Objects
                        if (typeof item === 'object' && item.isPlaceholder) {
                            placeholders.push(item);
                            return;
                        }

                        // Handle Strings (and potentially other objects if we expand)
                        const text = typeof item === 'string' ? item : item.text;
                        if (!text) return;

                        const parsed = parseIngredient(text);
                        const key = `${parsed.name.toLowerCase()}|${parsed.unit.toLowerCase()}`;

                        if (merged[key]) {
                            if (parsed.quantity !== null && merged[key].quantity !== null) {
                                merged[key].quantity += parsed.quantity;
                            } else if (parsed.quantity !== null) {
                                merged[key].quantity = parsed.quantity;
                            }
                        } else {
                            merged[key] = { ...parsed };
                        }
                    });

                    // Convert merged ingredients to rich objects
                    const ingredients = Object.values(merged).map(item => {
                        let text;
                        if (item.quantity !== null) {
                            const qty = item.quantity % 1 === 0 ? item.quantity : item.quantity.toFixed(1);
                            text = `${qty}${item.unit ? item.unit : ''} ${item.name}`;
                        } else {
                            text = item.name;
                        }
                        // Return unified structure
                        return { 
                            text, 
                            isPlaceholder: false, 
                            name: item.name, 
                            quantity: item.quantity, 
                            unit: item.unit 
                        };
                    });

                    // Combine and Sort
                    return [...placeholders, ...ingredients].sort((a, b) => a.text.localeCompare(b.text));
                };

                const mergedGroceryList = computed(() => getMergedItems());

                const openExportModal = () => {
                    const items = getMergedItems().sort((a, b) => a.name.localeCompare(b.name));
                    exportText.value = items.map(item => {
                        if (item.isPlaceholder) return item.text;
                        
                        if (item.quantity !== null) {
                            const qty = item.quantity % 1 === 0 ? item.quantity : item.quantity.toFixed(1);
                            return `${item.name}: ${qty}${item.unit ? item.unit : ''}`;
                        }
                        return item.name;
                    }).join('\n');
                    showExportModal.value = true;
                };

                const loadingIngredientsFor = ref(null); // track proposalId being loaded

                const retryLoadingIngredients = async (item) => {
                    if (!item.proposalId) return;
                    loadingIngredientsFor.value = item.proposalId;

                    // Find index in raw list
                    const rawIndex = groceryList.value.findIndex(g => typeof g === 'object' && g.proposalId === item.proposalId);
                    
                    try {
                        const res = await fetch('/api/ai/recipe', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ dish_name: item.dishName })
                        });
                        const data = await res.json();
                        
                        if (data.ingredients && data.ingredients.length > 0) {
                            // Update Proposal
                            const slotKey = getSlotKey(item.date, item.type);
                            const slot = mealSlots.value[slotKey];
                            if (slot) {
                                const prop = slot.proposals.find(p => p.id === item.proposalId);
                                if (prop) {
                                    prop.ingredients = data.ingredients;
                                    prop.instructions = data.instructions;
                                    prop.recipeUrl = data.url;
                                }
                            }
                            
                            // Remove placeholder
                            if (rawIndex > -1) groceryList.value.splice(rawIndex, 1);
                            
                            // Add new ingredients
                            const existingStrings = groceryList.value.map(g => typeof g === 'string' ? g : g.text);
                            const newItems = data.ingredients.filter(i => !existingStrings.includes(i));
                            groceryList.value.push(...newItems);
                            
                            logActivity('edit', `hat Zutaten f√ºr "${item.dishName}" nachgeladen`);
                        } else {
                            alert("Leider wurden keine Zutaten gefunden.");
                        }
                    } catch (e) {
                        console.error(e);
                        alert("Fehler beim Laden der Zutaten.");
                    } finally {
                        loadingIngredientsFor.value = null;
                    }
                };

                return {
                    currentUser, roles, days, mealTypes, login, logout,
                    getRoleIcon, formatDate, isSignatureDish, getProposals, hasVotedFor, isLeading, getProposalClass,
                    syncStatus, syncMessage, groceryList, findRecipe, approveDish, slotIsApproved, deleteProposal,
                    showProposalModal, activeSlot, proposalSearchQuery, suggestions, isSearching,
                    openProposalModal, closeProposalModal, debouncedSearch, selectSuggestion, submitProposalFromModal,
                    selectedRecipeProp, openRecipeModal, closeRecipeModal, withdrawProposal,
                    previewData, isLoadingPreview,
                    editingGroceryIndex, editingGroceryText, newGroceryItem,
                    startEditGrocery, saveGroceryEdit, cancelGroceryEdit, removeGroceryItem, addGroceryItem,
                    activityLog, showActivityLog, formatLogTime, mergedGroceryList,
                    showExportModal, exportText, openExportModal,
                    isCopyMode, startCopyMode, stopCopyMode, isTargetSlot, handleSlotCopyClick, duplicateSource,
                    retryLoadingIngredients, loadingIngredientsFor
                };
            }
        }).mount('#app');
    </script>

    <style>
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(5px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .animate-fade-in {
            animation: fadeIn 0.2s ease-out;
        }
    </style>

</body>

</html>